# 位运算
将操作数转成二进制数进行运算

## 概念
### 原码
整数的二进制表示、最高位表示符号位，0表示正数，1表示负数

### 反码
解决正负数运算问题，正数的反码还是原码、负数的反码是除了符号位、其他位按位取反获得的结果

### 补码
反码加1就是补码，解决+0和-0的问题以及正负数运算的问题

### 有符号整数
> 在 ECMAScript 中使用31位表示整数的数值，32位表示整数的符号，0为正数，1为负数。有符号正数可以表示正数和负数，正数以正常32存储，前31位表示数值，第32位为0。负数则使用二进制补码来表示。

### 无符号整数
> 位32为数值位，表示的值为 2 ^ 31，不表示符号，因此无符号整数表示的范围是 0 ~ 4294967295，而有符号整数表示范围为 -2147483648 ~ 2147483647，所以对于小于 2147483647 来说，无符号整数显示和有符号整数是一样的，大于该值，则使用位31来表示数值。

**注意：在 ECMAScript 中字面量创建的整数都是有符号整数，只有位运算才能创建无符号整数**

### 与运算 &
同位都为1才为1，否则为0

### 或运算 |
同位都为0才为0，其他都为1

### 取反运算 ~
同位为1，取0，为0，取1

### 异或运算 ^
同位相同为0，不同为1

### 有符号左移 <<
将二进制数左移n个单位，即在二进制数后面添加n个0，其实就是某个数 * 2的n次方

```javascript
3 << 2 = 12
// 相当于
3 * 2 ^ 2 = 12
```

### 有符号右移 >>
将二进制数右移n个单位，即在删除二进制数后面n位，其实就是某个数 / 2的n次方，跟左移操作刚好相反

```javascript
12 >> 1 = 6
// 相当于
12 / 2 ^ 1 = 6
```

### 无符号右移 >>>
正数情况下，无符号右移的结果和有符号右移的结果一样，负数情况下，无符号右移则会得到负数的二进制补码，即会变成一个32位的正数，这个数是非常大的

```javascript
-18 >>> 0 = 4294967278
```

## 运用

### 变量交换

```javascript
let a = 13, b = 17;
a = a ^ b;
b = a ^ b;
a = a ^ b;
console.log(a); // 17
console.log(b); // 13
```

### 判断奇偶
利用奇数的二进制末位是1，偶数的二进制末位是0的条件来判断奇偶

```javascript
num & 1 = 1; // num是奇数
num & 1 = 0; // num是偶数
```

### 数组元素个数计数

1. 只出现一次的元素
```javascript
function singleNumber (nums) {
  let a = 0;
  // 异或运算
  // 任何数异或0等于本身，本身异或本身等于0
  // 如果某个数出现两次，则结果为0，那么0再去异或出现一次的数则结果为出现一次的数
  // 推论：任何数异或0的结果再去异或偶数次的任何数，最后还是为0
  for (let i = 0; i < nums.length; i++) {
    a ^= nums[i];
  }
  return a;
};
console.log(singleNumber([2,2,2,2,1,8,8,6,6,6,6])) // 1
```

2. 出现次数最多的元素

```javascript
function majorityElement (nums) {
  // mid获取数组中位数
  let res = 0, mid = nums.length >> 1;
  for (let j = 0; j < 32; j++) {
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
      count += nums[i] >> j & 1;
      if (count > mid) {
        res += 1 << j;
        break;
      }
    }
  }
  return res;
};
console.log(majorityElement([2,2,1,1,1,2,2,2,1,1,1])); // 1
```

### 二进制逆序

```javascript
function reverseBits (n) {
  let result = 0;
  for (let i = 0; i < 32; i++) {
    console.log(`result二进制：${result.toString(2)}`);
    console.log(`result << 1: ${result << 1}`);
    console.log(`n & 1: ${n & 1}`);
    result = (result << 1) + (n & 1);
    console.log(`n的二进制：${n.toString(2)}`);
    n >>= 1;
    console.log(`n >>=1 之后的二进制：${n.toString(2)}`)
  }
  return result >>> 0;
};
```
